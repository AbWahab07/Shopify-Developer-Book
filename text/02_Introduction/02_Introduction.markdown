### Introducing the Shopify Platform ###

Since it's release to the public as a hosted e-commerce platform, Shopify has evolved through the adoption of new functionalities, the introduction of new features, as well as the refinement of the interface presented to Shop owners. As much as we all know competition drives companies to improve their products and services, in the niche domain of hosted e-commerce there are enough platforms to choose from that the decision to use one does require some careful study, thought and analysis. My experience over the years as a Shopify developer has informed me on how best to use the platform and when not to shut the door on possibilities.

## Shop Administration ##

One of the most important aspects of setting up and managing a shop for online sales has to be the user interface to inventory, sales and all the many aspects that make the shop function live. The original Shopify provided some basic templates to work off of, and the support for setting up an inventory of products and collections. Initially there was a limited amount of functionality but it was certainly possible to open up a shop quickly that looked pretty decent. As the user base expanded to hundreds and then thousands of users, the administrative interface became the focus of much attention. Every little button or link click became an issue, and soon there was a lot of public discussion and scrutiny on how it all worked. There has always been a team dedicated to improving the administration interface and so today it functions as an example of well-thought out user interface design that relies on incremental change as opposed to radical make-overs. Considering the backlash a lot of web applications generate by changing the look and feel of interfaces, I think Shopify has done a great job of delivering improvements while at the same time relying on a consistent delivery of services. As an example, the early version of tags was a text based interface. Adding or removing tags was not awkward but it was also not really clear how they worked to improve a shop. By providing some guidance on how tags can be used with collections and the idea of filtering inventory, they became a much more useful part of administration. Today the tags are managed with a nice interface of clickable pills. 


## Liquid Templating ##

As web application developers we have been treated over the years to numerous patterns and styles for delivering the HTML that makes up the *look* of our application. The first platforms to gain popularity were only capable of rendering results through a combination of spaghetti code. Mixing scripting code with output. PHP was and still is one of the best examples of this pattern where you can be sure developers will render a list, a form or some other elements directly with their PHP constructs. The problem with this tangled mess is that it keeps designers and integrators handicapped as they have to decipher scriptuing code while trying to add their HTML, CSS and Javascript flair. Some time passed and their was progress in separating the two camps. The next stage was to introduce templating to web applications. A template would render the look, and scripting would pump data to the templates. That is a fine pattern for systems where the end user is also the owner of the data. 

With a hosted platform like Shopify there is simply no chance that a shop can have access to the back end database due to security, and the almost certain probability that a shop would manage to destroy valuable data with a single erroneous command. Hence the need for a templating system that could not only provide secure and non-destructive access the data of a shop, but to do that while providing some sophistication in terms of rendering. The resulting project created by Tobias Luttke was Liquid, an open-source templating language that is the real star of the Shopify platform. Liquid is really interesting in that it provides access to data without requiring users to have secret database passwords, or even the ability to create and run database queries. Liquid provides common programming idioms like looping over sets of data, making conditional branches to do one thing or another, and also has been setup with Shopify to provide a large set of very useful filters that can be applied to data. 

The process of how Shopify uses Liquid is sometimes missed by clients, so I explain it this way. Shopify receives a request from somewhere on the Internet to render a shop at someshop.myshopify.com. Shopify locates that shop, and grabs the theme.liquid file specified by the shop. Going through the theme code, line by line, a series of assets get pulled into the theme that are usually the cascading style sheets (CSS) and Javascript needed by the shop. Each theme has to specify the content of the current request which could be the homepage, a blog, a collection or the cart. Shopify determines the correct liquid theme file to pull in and adds it to the theme. Finally, a theme can specify snippets of Liquid code to include in the theme. Sometimes it is beneficial to take special aspects of a shop like a front page carousel showing off products and keeping all that code together in a snippet. That way, it can be re-used on other parts of the site easier by simply including the snippet in the theme liquid file that needs the carousel. Once all of the code is assembled, the Shopify platform converts all the Liquid templating into HTML that gets injected into the theme. Since a theme is really just HTML and Liquid, once the Liquid is converted into HTML there is a complete HTML page that can be delivered to the original person that requested the page. 

The implication here for developers to note is that they cannot inject code into Liquid. You cannot use Javascript to alter Liquid for example. Instead, you have to recognize that Liquid is going to completely render and provide the HTML DOM that is crucial to client side scripting. Shopify provides some excellent opportunities to take advantage of this Liquid rendering stage with themes. Any settings that a theme provides are really just Liquid code that gets rendered when needed. One example of where this comes in handy is in the style sheets for a site. If someone wants to make their text bold and red instead of italic and blue, and there are theme settings for those options, the user can make the change using the Shopify Theme Settings link and not have to touch the theme code itself. The theme settings are Liquid, hence when a request come in, Shopify creates the css to deliver to the browser substituting bold and red for the text. There is a huge amount of creativity that this kind of system encourages and at the same time, it keeps shop owners and developers honest in that they cannot break their shop or other shops without really trying hard. For example, if you write totally illegal and bad Liquid Shopify will usually flag the error and not allow you to save the erroneous code. That is one level of safeguard. Since Shopify is also all about speed, any Liquid that has been compiled into HTML will usually be aggressively cached meaning if 5, 10 or even 100 people all ask for the same shop at the same time, they will all get the same copy of the HTML in their browser, Shopify will not be compiling the Liquid 5, 10 or 100 times. This is why it is important as developers to write efficient Liquid too. It is very easy to setup loops within loops within loops to try and provide a clever shopping experience, but when analysed with an algorithmic eye, sometimes these Liquid constructs jump out as completely inefficient. Nonetheless, Shopify will not usually interfere with how people use Liquid on the platform. 

![Types of Shops](../images/TypesOfShops.png)

## Javascript API ##

There was time when Javascript was limited to working strictly on the HTML DOM as it was rendered in the browser. Web applications could use HTTP GET and POST to read HTML from servers and to send forms for processing. Every submit button or link click resulted in a whole new processed web page being sent to the browser. Microsoft provided Asynchronous HTTP calls that came to be widely known as Ajax. Still nothing more than an HTTP POST or GET, Ajax did allow a client to send a small amount of data to a server or service, and then listen for the reply which could come later using a callback. This pattern radically changed the web since it meant you could just replace a small part of a web site with new code and not the entire page. Shopify embraces this technology now with the Javascript API. Any Shopify site can include Javascript that sends requests to their Shop and then waits for the response. For example, with the Javascript API I can load a cart with 16 products, change the quantity of each one in the cart, and then I ask for the contents of the cart once it is all loaded up to see what is the total price of items in the cart. All from anywhere on the site, including the homepage, while on a blog article or while cruising through a collection of items for sale. I can set a cart note from the homepage. I can delete a product in the cart from the product page. There is a whole world of very useful scripting that can be done with basic Javascript and the Javascript API. One of the first things I ever do to a shop I work on is to add my own little factory of utility functions, as well as the Javscript API. Even if a client is reluctant to offer fancy features to their shop, I need this code running to just get the basic development done. I cannot imagine working on a shop without being able to query the cart from my Javascript developer console. It truly is a crucial and wonderful aspect of developing shops. 

There are four interesting Javascript files apart from the Shopify Javascript API that are available from Shopify to help make shops more sophisticated in the presentation of products. The most common is the *option selector* code available for shops that want to present products with various options like colour, size or material. The natural HTML element to use when presenting options is the  *select* element. The use of options can increase the number of variants dramatically. A product that has three colours, four sizes and six different materials generates seventy-two variants! Shopify allows up to one hundred variants per product. The Javascript option selector code presents each option in it's own select element making it pretty easy for a shopper to select from the colours, sizes and materials to quickly find the variant they want to purchase. 

For shops that take advantage of this option selector code and that let Shopify control inventory quantities there is a common issue where shoppers can select variants that are out of stock. In many cases shops may have sparse inventory meaning a lot of the options are presenting the sold out or unavailable text to shoppers. To avoid this Shopify offers another small Javascript file that will hide any options that are sold out allowing a shop to present only variants that are actually in stock. This is a very handy extension to the usual option selector code. 

Another handy Javascript pattern from Shopify gives a shop the ability to present estimated shipping costs in the cart where they can be seen before checkout. The code presents a form to collect the general location for delivery in the form of a zip or postal code, and then uses the Shopify API to query the shipping services setup for the shop. For shops that offer expensive small items eg: jewelery, or ones that offer relatively cheap large items eg: stuffed animals, shipping can be a real problem to accommodate well. Freight is calculated on dimensional packaging and not necessarily weight. The Shopify shipping estimator ca really help shoppers see the true price of a purchase before any shocks occur when checking out and that can really help converting carts into sales. 

A final useful Javascript code package available from Shopify is called the Customizr. If you have to collect a name for engraving on a glass baby bottle you sell, or to collect the initials to be monogrammed on a leather handbag, or any other number of customization tasks, it is almost certain you will have to collect this information using cart attributes. Cart attributes are passed right through checkout with the order and are available in the *Order Notes* section of the Shop's Orders tab when looking at an order's details. Attrributes that are collected in this way can be rendered in the order confirmation email to inform the client of the detail's of their purchase. Further excellent opportunities exist to help an online shop run in that orders can be sent to a custom App using WebHooks, ensuring a custom App can perform additional business logic based on the attributes present in an order. I describe this in more detail when talking of App customization. It should not be a surprise that using cart attributes to collect custom information is complex. Collecting data at the product or collection presentation level, recognizing previous customization efforts when switching to the cart and then back to the same product pages is challenging. Add to that the fact that shopper's will often want more than one of something, and the code has to now manage quantity as well. When shoppers remove an item from their cart, any corresponding cart attributes have to be removed as well. Since checkout is separate from the shop, if a shopper starts checkout and then decides to revisit the shop, all the customization has to be available. That means any code has to be rock solid and demonstrate a mastery of browser features like localStorage, cookies, and the ability to serialize data as JSON. Ultimately a shop owner has to be able to know which glass baby bottle gets etched with the name "Eddy" and which handbag gets the initials "G.B.H" or "S.N.F.U". Customizr can go a long way to making this possible without a major investment in custom Javascript code. 

## Shopify API ##

Along with the Javascript API that offers up client side access to the cart and functionality like estimated shipping rates and separated options, there is the Shopify API. Whenever I have access to a shop I can use the Apps tab to select the Manage Apps option. With this I can create a private App that provides an API access token and password that allow API access to a shop. Using the Shopify API command line interface (CLI) that is described elsewhere in this book, I can quickly open up a terminal console and query a shop using the API. Since I like Ruby scripting, with just a few lines of code I can alter every product in a shop to have a special Product Type or Vendor. To me this beats downloading the entire inventory, fixed those values in the resulting CSV and then re-uploading the products.

Since I joined the Shopify Partner program, when I login to the partner App with my account, I am able to create Apps too. An App has a name, and when created it generates an API token, a shared secret and can thus be installed in a Shop. An App can then issue HTTP requests with either XML or JSON payloads against a Shop where the App has been installed. This means the Shopify API can be used by an external App to provide additional functionality a shop does not come with by default. An App can be created to add features to just one shop and no others, or an App can be created that can be installed in thousands of shops, offering unique functionality to all of them at the same time. By hosting an App in the cloud it can be fairly easy to ensure that the App itself has enough resources to handle hundreds or thousands of installations. Of course some developers prefer to run their own servers in colocation facilities and that works equally well. 

The API is well described by Shopify so I am not going to duplicate those efforts here. Instead I am going to describe how the Shopify API and Apps can be leveraged by shops that require just a little bit extra to function. One example that I found justifies the use of a custom App is a Shop that sells Art. Art is a unique domain with some specific quirks that make it interesting. A painting is for sale, as a product and so the usual Shopify application will be fine. Paintings can be organized into collections just as they might be in a gallery or museum. The challenge is that a painting has a history. It has been toured around other galleries and museums. Each exhibition adds some value to the story the painting has to tell. That history is best captured as meta data resources attached to the painting, not something you stuff inside the paintings description. Using the API it is easy to capture this meta data and thus manage paintings for sale so that they render their own history without it being tightly coupled to the painting's description. A painting is also very much belonging to the Artist that created the painting. Shopify does not have much support for a construct like an Artist that has a name, a date of birth, a country of origin and a biography. Using an App and the API it is easy enough to capture Artists as resources and to describe them. 

Now to make a gallery shop easier to manage we want these extra resources to be available to the designer so they can be presented in the shop's theme without too much fuss. Shopify offers up an App Proxy that stands in as a special page in a shop. A gallery can thus point clients to this special page where the shop will render custom resources. As a quick example, using the Artist concept, when visiting the special page there is a special Liquid template installed by the App that contains some custom Liquid tags. 

    {{ artist.name }}
    {{ artist.country }}
    {{ artist.biography }}

When a shopper visits this special page there is a connection to the App that provides the App with the artist's identification. For example, the artist's name. The App also knows there exists a special Liquid template installed in the shop, so it reads that template since it could've been altered by the shop's theme designer. The App Proxy searches the App for the artist's information and once found, it replaces the liquid tags it knows with the appropriate information. With that step completed, the App then sends back the Liquid template for processing by Shopify. Shoppers now see custom artist information like a name, country and biography, along with a collection of the artist's paintings, rendered from a standard Shopify Collection.

The combination of the Shopify API, Apps and App Proxy provide developers with an amazing degree of latitude to make shops that go far beyond the basics of selling snowboards or t-shirts. Constant development and improvement to these platform features ensure the domain can only be more interesting and challenging as time passes. 

## Theme Store ##

In the early days of Shopify there were just a handful of basic themes available. Designers could download these themes as zip files and tinker with the HTML, Javascript, CSS and Liquid constructs using a text editor. There were only three ways to see the effect of editing a theme back then. One was to edit the theme, zip compress the changes and upload to the live theme. A second was to edit the theme inside the Shopify administration screen. Prior to decent text area editing this was not a great option. Thirdly Shopify provided a small self-contained web application called Vision where early adopters of Shopify could edit their themes. Vision provided a limited inventory and enough templates to show of basic theme changes. Quickly this approach was panned as it failed to keep up with progress in changs to live Shops, and most people had trouble wrapping their heads around theme changes that always showed snowboards for sale. The inventory of products and pages and collections could be hacked since it was just a YAML file representing a live inventory, but this was tedious and prone to error. I think most people were happy when Shopify abandoned Vision as moved to the superior model of providing test shops to work off of. Any Shopify Partner can create a test shop and load a theme into it to start working. Since you can also load an inventory into a test shop, they provide a great way to develop a theme without risk to borking a live shop. Along with test shops came a Theme store where you can download themes that are free and themes that cost money but come with nice features that might otherwise cost mooney to develop.

For talented web designers that understand the nuances of cross-browser issues with respect to Javascript and Cascading Style Sheets as well as Liquid scripting, getting a theme into the Theme store is a great way to become more popular, well-known and to make some money. It is probable that the first thing a new Shopify shop owner will invest in is the look of their shop, hence a visit to the Theme store. 

## App Store ##

Like the Theme store, when Shopify released the API and paved the way for Apps to be developed and integrated into shops, they created the App store too. The Shopify mantra of keeping the core Shopify code simple and free of complexity has ensured there is a need for Apps that can deliver the much needed extras e-commerce shops demand. There are slightly less then two hundred Apps that can installed in a shop as of early 2012 and this number is sure to continue climbing as shops demand more sophistication. 

For developers the App store offers the audience of all the shop owners and anyone researching the Shopify platform is also sure to take a tour of available Apps to see if Shopify is indeed suitable as their platform of choice. To make the financial aspect of developing Apps and providing them to shops easier on developers Shopify makes their billing API available to developers. In exchange for 20% of any App costs, be they one-time charges or recurring charges, Shopify collects the money for developers and deposits it in the App Partner account. I find this handy as it remains difficult to charge recurring or subscription fees in Canada since there is no access to services like Stripe in the United States. Other countries may have easier online banking available. 

It is also possible to setup one-time charges when you want to provide extra support services to clients. The billing API is just enough to help developers get their Apps in front of the entire Shopify subscriber base without incurring major administrative headaches. 

## Shopify Experts ##

As the years have passed and Shopify has grown and attracted many more clients, the number of shops includes some very high profile clients. They are interested in all the good features the platform offers but they also want to know that they can have their special needs taken care of without having to launch a complex search for talent. 

The Experts application was launched to showcase talent working on the Shopify platform. Designers can join and they get a chance to show off their themes and design work. When a custom theme is a must, it is important to choose a designer that understands how Liquid works and how to deliver a well conceived theme by leveraging the Shopify platform properly. 

For code developers like me, the Experts showcase is a way to inform people that need custom App scripting or custom Javascript that they have resources to contact. Combining deep knowledge of how the Shopify platform works from the theme templates, through the Javascript API and the Shopify API it is certainly a domain with enough complexity to attract devlopers that are experts at cloud computing, user interface coding, and a host of other skills. 

There are also slots in the Experts application for accountants and photographers as these skills are also very much in demand by shops that have the present the best possible look for their products and services, and to be able to do accurate reports on just what is flowing through their online universe.


